from datetime import datetime
from typing import Optional

from openai import AsyncOpenAI
from pydantic import BaseModel, Field, conlist, confloat

from chatwoot_api.chatwoot_client import ChatwootClient
from openai_agents.utils.formation_contact_correspondence import formation_contact_correspondence
from settings import OPENAI_TOKEN
from wazzup_collector_api.get_contact_chats import get_contact_chats


def get_analyze_prompt():
    """
    Возвращает промт с акутальной датой
    """
    now_iso = datetime.now().isoformat()
    return f"""
    Ты — Аналитик клиентских диалогов.
    
    Твоя основная задача: определить, стоит ли отправлять прогревающее сообщение клиенту на основе анализа переписки.
    
    Принципы оценки:
    - Уважай границы клиента — если он не отвечает, возможно, не готов к общению.
    - Учитывай контекст завершения — как закончился последний диалог.
    - Оценивай временные рамки — не все паузы означают потерю интереса.
    - Сохраняй позитивный и ненавязчивый подход.
    
    Критерии анализа:
    
    1. АНАЛИЗ ПОСЛЕДНЕГО ВЗАИМОДЕЙСТВИЯ
    
    НЕТ — не отправлять сообщение, если:
    - Клиент явно попросил не беспокоить или перезвонить позже.
    - Клиент отказался от услуг или сказал «не интересно».
    - В диалоге была конфликтная ситуация.
    - Клиент жаловался на навязчивость или частые сообщения.
    - Клиент три раза не ответил на прогревающие сообщения.
    - Клиент договорился с менеджером о звонке или встрече на конкретный день, и этот звонок/встреча ещё не произошли.
    
    ДА — отправлять сообщение, если:
    - Диалог завершился на позитивной ноте.
    - Клиент проявлял интерес, но нужно было время подумать.
    - Клиент просил информацию, которую тогда не предоставили.
    - Последний ответ клиента был коротким, но оставались незакрытые вопросы.
    - Ответ типа «изучу», «посмотрю позже» показывает сохранение интереса, и прошло достаточно времени.
    
    2. ВРЕМЕННОЙ ФАКТОР
    
    НЕТ — не отправлять сообщение, если:
    - Прошло менее 24 часов с момента последнего сообщения клиента.
    - Клиент писал «посмотрю позже», «изучу», и прошло менее 2–3 дней.
    - Последний ответ клиента был вечером/ночью, и прошло менее 12 часов рабочего времени.
    - Клиент получил большой объём информации, и прошло менее 3 дней.
    - Переписка велась в выходные, и сейчас только первый рабочий день.
    
    ДА — отправлять сообщение, если:
    - Прошло более 3–5 дней молчания без договорённости о дате.
    - Последний ответ клиента был «посмотрю», «надо подумать», и прошло более 4 дней.
    - Клиент получил материалы (PDF, смета, проект) и прошло 5–7 дней без реакции.
    - Диалог был оборван без завершения — пауза > 48 часов.
    - Последний ответ был кратким («ок», «понял»), и прошло ≥ 3 дней.
    
    3. ДОГОВОРЁННОСТИ О ВСТРЕЧАХ / ЗВОНКАХ
    
    - Определи, есть ли договорённость о конкретной дате и времени:
      - Звонок
      - Встреча в офисе или на объекте
      - Выезд на участок
      - Любая коммуникация, привязанная к дню/дате/времени
    
    Правила работы с датами:
    - Ищи формулировки: «давайте созвонимся 15 ноября», «встреча во вторник в 19:00», «жду вас 03.12», «переносим на 25 числа», «в субботу днём».
    - Если договорённостей несколько — актуальной считается последняя по хронологии, если она ещё не наступила.
    - Если дата прошла — не считать актуальной.
    - Если клиент несколько раз переносил встречу — ориентируйся на последнюю указанную будущую дату.
    - Если указано только «вечером», «днём», «утром» — выставляй стандартное время: «вечером» → 19:00, «днём» → 14:00, «утром» → 10:00, «после обеда» → 15:00.
    - Если указан день недели без конкретной даты — определяй ближайший будущий день недели относительно cегодняшней даты - {now_iso}.
    
    4. ЗАВЕРШЕНИЕ ДИАЛОГА
    
    ДА — завершить диалог только если:
    Грубый отказ клиента.
    Жалобы на общение или навязчивость.
    Конфликтная ситуация.
    Три непрочитанных сообщения вне зависимости от времени отправки.
    
    В остальных случаях - не завершать.
    """


class FollowupDecision(BaseModel):
    """Структурированный ответ модели о том, отправлять ли прогрев."""
    should_send: bool = Field(
        ...,
        description="Итоговое решение: отправлять ли прогревающее сообщение."
    )
    should_complete: bool = Field(
        ...,
        description="Итоговое решение: нужно ли завершать диалог (взаимодействие с клиентом)."
    )
    next_meeting_datetime: Optional[datetime] = Field(
        None,
        description=(
            "Дата и время ближайшей согласованной встречи/звонка/выезда с клиентом "
            "в формате ISO 8601. Если актуальных запланированных событий нет, значение null."
        )
    )

async def analyze_conversation(conv_id):
    """
    Анализирует диалог в Chatwoot на возможность продолжения переписки с клиентом
    """
    chat_history = []
    async with ChatwootClient() as cw:
        all_messages = await cw.get_all_messages(conv_id)
        contact_phone = await cw.get_contact_phone_by_conversation(conv_id)
        chats = await get_contact_chats(contact_phone)
        if chats:
            chats_string = formation_contact_correspondence(chats)
            if chats_string:
                chat_history.append({
                    "role": "assistant",
                    "content": f"[ПЕРЕПИСКА КЛИЕНТА С МЕНЕДЖЕРАМИ!]\n"
                               f"{chats_string}"})

    for msg in all_messages:
        role = "user" if msg.get("message_type") == 0 else "assistant"
        content = (msg.get("content") or "").strip()
        if not content:
            continue

        # преобразуем created_at в нормальный формат
        created_at = msg.get("created_at")
        if created_at:
            dt = datetime.fromtimestamp(created_at)
            weekdays_ru = ("понедельник", "вторник", "среда", "четверг", "пятница", "суббота", "воскресенье")
            weekday = weekdays_ru[dt.weekday()]
            dt_str = f'{dt.strftime("%Y-%m-%d %H:%M:%S")} ({weekday})'
        else:
            dt_str = "unknown"

        if msg.get("private"):
            chat_history.append({
                "role": "assistant",
                "content": f"[Внутренняя заметка, не транслируй клиенту дословно!] "
                           f"(отправлено {dt_str}): {content}"})
        else:
            chat_history.append({"role": role, "content": f"(отправлено {dt_str}) {content}"})

    openai_client = AsyncOpenAI(api_key=OPENAI_TOKEN) # в проде прокси не нужен

    resp = await openai_client.responses.parse(
        model="gpt-5-mini",
        instructions=get_analyze_prompt(),
        input=chat_history,
        text_format=FollowupDecision,
    )

    return resp.output_parsed
